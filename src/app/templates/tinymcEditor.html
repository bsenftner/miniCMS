<!DOCTYPE html>
{# 
	This is a Jinja2 template for an html page
	These lines are comments and are removed when the template is rendered. 
#}
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>MiniCMS</title>
  <link rel="stylesheet" href="/static/index.css">
</head>
<body>
	<div class="grid">
		{% include 'common_header.html' %}

		{# the left sidebar #}
		{% include 'common_lsidebar.html' %}

		<main>
			<div id="mainContent">
				{# the editor itself, embedded in a form, with a post's contents, and operation buttons #}
				<form id="editorForm" method="post">
					<label for="NewPostTitle">Title:</label>
  					<input type="text" id="NewPostTitle" name="label" value="{{contentPost.title}}">
					<div class="editorContainer">
						<div id="editor">
							{{contentPost.text | safe}}
  						</div>
					</div>
				</form>
				<div id="authorName">
					Author: {{contentPost.username}}, UserId: {{contentPost.userid}} 
					(The author cannot be changed.)
				</div>
				<form id="uploadForm">
					<div class="upload1">
						<label>Manual File Upload:</label>
					</div>
					<div class="upload2">
						<input type="file" id="NewUploadInput" name="label" onchange="onUploadChangeFunc();" >
					</div>
					<div class="upload3">
						<a href="#" class="button" id="uploadBttn" onclick="UploadFile()">Select a file first</a>
					</div>
				</form>
				<div id="divUploadMsg">
					Use the <b>Browse</b> button to select a file to upload; after selection that right-most button 
					becomes a 'start this upload' button
				</div>

				<div id="divUploadLinksHeader">
					Uploaded File Links:
				</div>
				<div id="divUploadLinksWrapper">
					<div id="divUploadLinksGridParent">
						<div id="divUploadLinksGrid0">
							filename.ext
						</div>
						<div id="divUploadLinksGrid1">
							mimetype
						</div>
						<div id="divUploadLinksGrid2">
							copy document link to clipboard
						</div>
						<div id="divUploadLinksGrid3">
							download this file
						</div>
					</div>
					<div id="divUploadLinksGridParent">
						<div id="divUploadLinksGrid0">
							filename.ext
						</div>
						<div id="divUploadLinksGrid1">
							mimetype
						</div>
						<div id="divUploadLinksGrid2">
							copy document link to clipboard
						</div>
						<div id="divUploadLinksGrid3">
							download this file
						</div>
					</div>
					<div id="divUploadLinksGridParent">
						<div id="divUploadLinksGrid0">
							filename.ext
						</div>
						<div id="divUploadLinksGrid1">
							mimetype
						</div>
						<div id="divUploadLinksGrid2">
							copy document link to clipboard
						</div>
						<div id="divUploadLinksGrid3">
							download this file
						</div>
					</div>
					<div id="divUploadLinksGridParent">
						<div id="divUploadLinksGrid0">
							filename.ext
						</div>
						<div id="divUploadLinksGrid1">
							mimetype
						</div>
						<div id="divUploadLinksGrid2">
							copy document link to clipboard
						</div>
						<div id="divUploadLinksGrid3">
							download this file
						</div>
					</div>
				</div>
				<div id="divUploadLinksMsg">
					Previously uploaded files. 
					Use <b>Copy document link to clipboard</b> to generate the 'embed text' to use an 
					uploaded file in memo or comment text
				</div>
				<div id="statusList">
					<div id="statusSelectionDiv">
						<label for="statusSelectBox">Status:</label>
						<select id="statusSelectBox" onchange="onStatusSelectChangeFunc();">
							<option value="unpublished">Unpublished</option>
    						<option value="published">Published</option>
						</select>
					</div>
					<div id="statusSelectionMsg">
						Unpublished memos are not shown to others. Unpublished memos are 
						only visible to the author. Published memos are visible to users with 
						the same access roles as the memo as well as the memo author. 
					</div>
				</div>
				<div>
					<div id="PostAccessSelectionDiv">
						<label for="NewPostAccess">Access:</label>
						<select id="NewPostAccess">
							<option value="admin">Admin</option>
    						<option value="staff">Staff</option>
    						<option value="public">Public</option>
						</select>
					</div>
					<div id="AccessSelectionMsg">
						Selecting <b>Admin</b> makes the memo only visible to management and the memo author. 
						<br/>
						Selecting <b>Staff</b> makes the memo visible to all employees. 
						<br/>
						Selecting <b>Public</b> makes the memo visible to anyone with a web browser.
						<br/>
						Public memos can only be created by admins. 
						<br/>
						Consider memos company notices and company-wide discussions. 
					</div>
				</div>
				<div>
					<label for="NewPostTags">Tags:</label>
  					<input type="text" id="NewPostTags" name="label" value="{{contentPost.tags}}">
					<div id="TagsMsg">Tags are words used to group memos of similar topic together, separated by spaces.</div>
				</div>
				<div id="divBeneathTheEditor">
					<a href="#" class="button" onclick="MemoEditCancel()">Cancel</a>
					<a href="#" class="button" onclick="MemoUpdate()">Update</a>
					<a href="#" class="button" onclick="MemoDelete()">Delete</a>
					<br/>
					<!-- <a href="#" class="button" onclick="MemoSubmit()">Post A Completely New Memo</a> -->
				</div>
			</div>
		</main>

		<aside>
			<div id="aside">
				<a href="#" class="button" onclick="Login()">Login</a>
			</div>
		</aside>
  
	<footer>
		{{ frags[0].footer | safe }} 
	</footer>
	</div>

	{% include 'common_ifAccessDo.html' %}

	
	<!-- for html syntax hilighting -->
	<link
  		rel="stylesheet"
  		href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.2/styles/github.min.css"
	/>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.2/highlight.min.js"></script>
	<script
  		charset="UTF-8"
  		src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.2/languages/xml.min.js">
	</script>

	{% include 'common_editStyle.html' %}

    <!-- include the TinyMCE editor -->
	<script src="https://cdn.tiny.cloud/1/tpl8zzz2nyqln68299z0tf9u4m2p3hi6c9qxgr7gal0i454q/tinymce/6/tinymce.min.js" referrerpolicy="origin"></script>

	<script>

        // configure the TinyMCE editor 
        tinymce.init({
            selector: '#editor',
            convert_urls: false,
            plugins: 'anchor autolink charmap code codesample emoticons image link lists media searchreplace table visualblocks wordcount',
            toolbar: 'undo redo | code | blocks fontfamily fontsize | bold italic underline strikethrough | link image media table mergetags | addcomment showcomments | spellcheckdialog a11ycheck | align lineheight | checklist numlist bullist indent outdent | emoticons charmap | removeformat',
        });


		document.addEventListener( "DOMContentLoaded", function(){page_init();} );
	
		let gUser = {};

		function page_init_work(userdata) {

			gUser = userdata;

			// user is logged in, change right sidebar links:
							
			document.getElementById("aside").innerHTML = 
							`<a href="#" class="button" onclick="UserSettings()">Settings</a>
							 <br/><br/>
							 <a href="#" class="button" onclick="Logout()">Logout</a>
							`;

			// make sure memo status is reflected in the selection widget:
			document.getElementById("statusSelectBox").value = "{{contentPost.status}}"
			//
			document.getElementById("NewPostAccess").value = "{{contentPost.access}}"

			if (Number("{{contentPost.memoid}}") == 0) {
				// we're creating a new memo, so change the button options:
				document.getElementById("divBeneathTheEditor").innerHTML =
					`<a href="#" class="button" onclick="MemoEditCancel()">Cancel</a>
					<a href="#" class="button" onclick="MemoSubmit()">Post A New Memo</a>
					`;
			}

			if (userdata.hasOwnProperty('roles')) {
				if (userdata.roles.includes('staff') && !userdata.roles.includes('admin')) {
					// we know user is staff, not admin, so reduce the access options to staff only:
					let newPostAccess = document.getElementById("NewPostAccess")
					//
					let i;
					//
					for (i = newPostAccess.options.length; i >= 0; i--) {
						newPostAccess.remove(i);
					}
					//
					let optn = document.createElement("OPTION");
					optn.text = 'Staff';
					optn.value = 'staff'; 
					newPostAccess.options.add(optn);
				}
			}

			get_uploads(); // read and then populate the upload links grid
		}
		//
		function page_init() {
			ifAccessDoWithUser(page_init_work);
		}

		function MemoEditCancel() { window.location.href = "/memopage/{{ contentPost.memoid }}"; }

		function MemoSubmitWork() {
			// get the post label:
			var newPostTitle = document.getElementById("NewPostTitle").value;
			// Get HTML content
			var newPostHTML = tinymce.get("editor").getContent();
			// get the post status:
			var newPostStatus = document.getElementById("statusSelectBox").value;
			// get the post access:
			var newPostAccess = document.getElementById("NewPostAccess").value;
			// get the post tags:
			var newPostTags = document.getElementById("NewPostTags").value;

			// post as new memo submission:
			const params = {
				"title": newPostTitle, 
				"text": newPostHTML,
				"status": newPostStatus,
				"access": newPostAccess,
				"tags": newPostTags,
				"userid": gUser.userid,
				"username": gUser.username,
			};
		
			const options = {
				method: 'POST',
				headers: {
					  'Accept': 'application/json',
					  'Content-Type': 'application/json',
					  // "Authorization": "Bearer " + access_token // only needed when JWT is not in cookie
				},
				body: JSON.stringify( params )  
			};
			fetch( '/memo/', options )
				.then( response => response.json() )
				.then( response => {
					// Do something with response.
					// console.log( response )
					if (response.hasOwnProperty('detail')) {
						alert( 'Please fix the following and try again: ' + response.detail )
					}
					else if (response.hasOwnProperty('memoid')) {
					//	window.location.href = "/memopage/" + response.id.toString();
						window.location.href = "/memopage/" + response.memoid;
					}
					else {
						console.log( response )
					}
				})
				.catch(err => {
					// Do something with the error
					console.log(err) 
					alert( err )
					// window.location.href = "/memopage/{{ contentPost.userid }}";
				}) 
		}
		function MemoSubmit() {
			ifAccessDo(MemoSubmitWork);
		}

		function MemoUpdateWork() {
			const someData = {
				"title": document.getElementById("NewPostTitle").value, 
				"text": tinymce.get("editor").getContent(),
				"status": document.getElementById("statusSelectBox").value, 
				"access": document.getElementById("NewPostAccess").value, 
				"tags": document.getElementById("NewPostTags").value, 
				"userid": gUser.userid,
				"username": gUser.username,
			}
			//
			const options = {
				credentials: 'include',
				method: 'PUT', // Method itself
				headers: {
				 		'Content-type': 'application/json; charset=UTF-8', // Indicates the content 
				 		// "Authorization": "Bearer " + access_token // only needed when JWT is not in cookie
				},
				body: JSON.stringify(someData) // We send data in JSON format
			}
			   
			// make the HTTP put request using fetch api
			let domain = (new URL(window.location));
			const prebsjnk = domain.origin;
			const furl = prebsjnk + '/memo/{{ contentPost.memoid }}';
			fetch(furl, options) 
			// .then(response => response.json())
			.then(response => 
			{
				if (response.ok) {
					window.location.href = "/memopage/{{ contentPost.memoid }}";
				}
				else {
					alert( 'Problem updating. Are you sure the access groups are valid and separated by spaces?' )
				}
			}) 
			.catch(err => {
				// Do something with the error
				console.log(err) 
				alert( err )
				window.location.href = "/memopage/{{ contentPost.memoid }}";
			}) 
		}
		function MemoUpdate() {
			ifAccessDo(MemoUpdateWork);
		}

		function MemoDeleteWork() {
			const options = { 
				method: 'DELETE',
				// headers: { "Authorization": "Bearer " + access_token } // only needed when JWT is not in cookie
			};
			fetch( '/memo/{{ contentPost.memoid }}', options )
				.then( response => response.json() )
				.then( response => {
					// Do something with response:
					console.log( response )
					if (response.memoid != '{{ contentPost.memoid }}')
					{ 
						console.log( "DELETE ERROR!" )
						alert( "DELETE ERROR!" )
						
					}
					window.location.href = "/";

				} )
				.catch(err => {
					// Do something with the error
					console.log(err) 
					alert( err )
					window.location.href = "/memopage/{{ contentPost.memoid }}";
				});
		}
		function MemoDelete() {
			ifAccessDo(MemoDeleteWork);
		}

		// called when the status dropdown selection changes:
		function onStatusSelectChangeFunc() {
			let statusSelectBox = document.getElementById("statusSelectBox")
			let selected = statusSelectBox.value;
		}


		// called when the Input File's browse button has been operated and it's value changed:
		function onUploadChangeFunc() {
			fileInputCtrl = document.getElementById("NewUploadInput")

			let selected = fileInputCtrl.value; 	// has fake path components before filename
			const pathArray = selected.split("\\");	// prepare...
   			const lastIndex = pathArray.length - 1; // ...to remove...
			selected = pathArray[lastIndex];		// ...path components.

			fileUploadButton = document.getElementById("uploadBttn")
			fileUploadButton.innerHTML = 'Upload "' + selected + '"'

			document.getElementById("divUploadMsg").innerHTML = 'Now use the <b>Upload "' + selected + '"</b> button to upload the file'
		}
		//
		function UploadFile() {
			// Select your input type file and store it in a variable
			const input = document.getElementById('NewUploadInput');

			var data = new FormData()
			data.append('file', input.files[0])

			// This will upload the file after having read it
			const upload = (file) => {
				fetch('/upload', { // Your POST endpoint
	  				method: 'POST',
	  				headers: {},
	  				body: data // This is your file object
				}).then(
	  				response => response.json() // if the response is a JSON object
				 ).then(
	  				success => {
						console.log( success.message) // Handle the success response object
						document.getElementById("divUploadMsg").innerHTML = '<p>Success msg: ' +  success.message + '</p>';
						//
						// populate listbox for upload selection:
						get_uploads();
						//
						// clear the file upload ctrl, now that the file has been uploaded
						fileInputCtrl = document.getElementById("NewUploadInput")
						fileInputCtrl.value = '';
						//
						fileUploadButton = document.getElementById("uploadBttn")
						fileUploadButton.innerHTML = 'Select a file first'
					}
				 ).catch(
	  				error => {
						console.log( error ) // Handle the error response object
						document.getElementById("divUploadMsg").innerHTML = '<p>Error msg: ' + error + '</p>';
					}
				);
  			};
  
  			upload(input.files[0]);
		}


		// get list of uploaded files and populate upload selection list:
		const get_uploads = () => {
			let domain = (new URL(window.location));
			const prebsjnk = domain.origin;
			const furl = prebsjnk + '/upload';
			fetch(furl, { // GET endpoint
				  method: 'GET',
				  headers: {}
			}).then(
				  response => response.json() // if the response is a JSON object
			 ).then(
				  success => {
					
					console.log( success ) // Handle the success response object

					let uploadLinksWrapper = document.getElementById("divUploadLinksWrapper")
					uploadLinksWrapper.innerHTML = '';

					let fileLinks = success;
					for (let i = 0; i < fileLinks.length; i++) {
						let filename = fileLinks[i].filename;
						let fnParts = filename.split('.');
						let ext = fnParts[ fnParts.length - 1 ].toLowerCase();
						let fileType = fileLinks[i].type;
						let fileLink = fileLinks[i].link;
						
						// set this first:
						let dwnloadBttn = `<a href="#" class="button" onclick="DownloadFile('${fileLink}','${filename}')">Download this file</a>`;
						
						let docLinkBttn = `<a href="#" class="button" onclick="navigator.clipboard.writeText('${fileLink}')">Copy link to clipboard</a>`;
						if (fileType != 'image' && fileType != 'media') {
							docLinkBttn = 'cannot embed in memo/comment';
							if (ext == 'pdfXX') {
								let pdfLink = `<iframe src="` + fileLink + `" width='100%' height='200px'></iframe>`;
								let click = '"navigator.clipboard.writeText(\"' + pdfLink + '\")"';
								docLinkBttn = '<a href="#" class="button" onclick=' + click + '>Copy embed text to clipboard</a>';
							}
						}
						else if (fileType == 'media') {
							docLinkBttn = `<a href="#" class="button" onclick="navigator.clipboard.writeText('/video/${filename}')">Copy link to clipboard</a>`;
						}
						let markup = `
						<div id="divUploadLinksGridParent">
							<div id="divUploadLinksGrid0">
								<b>${filename}</b>
							</div>
							<div id="divUploadLinksGrid1">
								${fileType}
							</div>
							<div id="divUploadLinksGrid2">
								${docLinkBttn}
							</div>
							<div id="divUploadLinksGrid3">
								${dwnloadBttn}
							</div>
						</div>`;

						uploadLinksWrapper.innerHTML += markup;
					}
				}
			 ).catch(
				  error => {
					console.log( error ) // Handle the error response object
				}
			);
		  };

		// called when "Download this file" buttons are clicked
		function DownloadFile(fileUrl, filename) {
			fetch(fileUrl)
			.then(resp => resp.blob())
			.then(blob => {
				const url = window.URL.createObjectURL(blob);
				const a = document.createElement('a');
				a.style.display = 'none';
				a.href = url;
				a.download = filename;
				document.body.appendChild(a);
				a.click();
				window.URL.revokeObjectURL(url);
				alert('"' + filename + '" has downloaded.'); 
			})
			.catch(() => alert('oh no!'));
		}

		function UserSettings() { window.location.href = "/Settings"; }

	</script>

	{% include 'common_logout.html' %}

	{% include 'common_refresh.html' %}


</body>
</html>
