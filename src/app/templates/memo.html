<!DOCTYPE html>
{# 
	This is a Jinja2 template for an html page
	These lines are comments and are removed when the template is rendered. 
#}
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>MiniCMS</title>
  <link rel="stylesheet" href="/static/index.css">

</head>
<body onload="slidesInit()">
	<div class="grid">
		{% include 'common_header.html' %}

		{# the left sidebar #}
		{% include 'common_lsidebar.html' %}

		{# the main content area #}
		<main>
			<div id="mainContent">
				{# title and post contents, with an optional edit button #}
				<H1> {{contentPost.title}} </H1>
				<div class="ql-editor">
					{{contentPost.text | safe}}
				</div>
                <div class="memoMetadata">
				    <h5 class="g1">Author: {{contentPost.username}}</h5>
				    <h5 class="g2">Status: {{contentPost.status}}</h5>
				    <h5 class="g3">Access: {{contentPost.access}}</h5>
				    <h5 class="g4">Tags: {{contentPost.tags}}</h5>
                </div>
			</div>
            <div id="commentsTop">
                Comments:
            </div>
            <div id="existingComments">
                No comments yet; be the first to comment...
            </div>

			<div id="commentEditorContainer">
				<form id="editorForm" method="post">
					<div class="editorContainer">
						<div id="editor">
							comment...
						</div>
					</div>
				</form>
				
				<div class="memoMetadata">
					<a href="#" class="button g5" id="showHideUploadsDownloads" onclick="ToggleUploadDownloadSet()">Show / Hide Uploads & Links</a>
				</div>

				<div id="uploadDownloadSet">
					<form id="uploadForm">
						<div class="upload1">
							<label>Manual File Upload:</label>
						</div>
						<div class="upload2">
							<input type="file" id="NewUploadInput" name="label" onchange="onUploadChangeFunc();" >
						</div>
						<div class="upload3">
							<a href="#" class="button" id="uploadBttn" onclick="UploadFile()">Select a file first</a>
						</div>
					</form>
					<div id="divUploadMsg">
						Use the <b>Browse</b> button to select a file to upload; after selection that right-most button 
						becomes a 'start this upload' button
					</div>

					<div id="divUploadLinksHeader">
						Uploaded File Links:
					</div>
					<div id="divUploadLinksWrapper">
						<div id="divUploadLinksGridParent">
							<div id="divUploadLinksGrid0">
								filename.ext
							</div>
							<div id="divUploadLinksGrid1">
								mimetype
							</div>
							<div id="divUploadLinksGrid2">
								copy document link to clipboard
							</div>
							<div id="divUploadLinksGrid3">
								download this file
							</div>
						</div>
					</div>
					<div id="divUploadLinksMsg">
						Previously uploaded files. 
						Use <b>Copy link to clipboard</b> to generate the 'embed text' to use an 
						uploaded file in the editor's text
					</div>
				</div>

				<a href="#" class="button" onclick="PostComment()">Post Comment</a>
			</div>

		</main>

		{# the right sidebar #}
		<aside>
			<div id="aside">
				<a href="#" class="button" onclick="Login()">Login</a>
				<br/>
				<a href="#" class="button" onclick="Register()">Register</a>
			</div>
		</aside>
  
	<footer>
		{{ frags[0].footer | safe }} 
	</footer>
	</div>

	{% include 'common_slides.html' %}

	{% include 'common_editStyle.html' %}

    <!-- include the TinyMCE editor -->
	<script src="https://cdn.tiny.cloud/1/tpl8zzz2nyqln68299z0tf9u4m2p3hi6c9qxgr7gal0i454q/tinymce/6/tinymce.min.js" referrerpolicy="origin"></script>

	<script>

		document.addEventListener("DOMContentLoaded", function() {
			page_init();
			slidesInit();
			setTimeout( slidesInit, 3000 );
		});
		//
		gUser = {};
		//
		function page_init() {

			const access_token = localStorage.getItem('token');
			if (typeof access_token !== 'undefined') {
				
				const options = { headers: { "Authorization": "Bearer " + access_token } }
				fetch("/users/me", options)
				.then(response => response.json())
				.then( response =>  {

					gUser = response;

					if (gUser.hasOwnProperty('roles')) {

						// user is logged in, change right sidebar links:
						document.getElementById("aside").innerHTML = 
						`<a href="#" class="button" onclick="UserProfile()">Profile</a>
						<br/><br/>
						<a href="#" class="button" onclick="UserSettings()">Settings</a>
						<br/><br/>
						<a href="#" class="button" onclick="Logout()">Logout</a>
						`;

						let status = "{{contentPost.status}}";
						if (gUser.userid == '{{ contentPost.userid }}') {
							// user is author
							if (status.includes('unpublished')) {
								// memo is unpublished:
								document.getElementById("mainContent").innerHTML += 
									'<a href="#" class="button" onclick="MemoEdit()">Edit Unpublished Memo</a>';
	
							}
						}
						else if (gUser.roles.includes("admin")) {
							// user is admin:
							if (status.includes('unpublished')) {
								document.getElementById("mainContent").innerHTML += 
								'<a href="#" class="button" onclick="MemoEdit()">Edit Unpublished Memo (not your memo)</a>';
							}
							else if (status.includes('published')) {
								document.getElementById("mainContent").innerHTML += 
								'<a href="#" class="button" onclick="MemoEdit()">Edit Published Memo (not your memo)</a>';
							}
						} 

						if (status.includes('unpublished')) {
							document.getElementById("existingComments").innerHTML = 
								'<p>Commenting available after memo is published</p>';
							
							document.getElementById("editorForm").style.display = 'none';
						}
						else {
							LoadComments();
							get_uploads();
						}
					}
					else {
						// something is wrong, user should not be on this page:
						gUser = {};
						window.location.href = "/";
					}
				});
			}
		}

        // configure the TinyMCE editor for comments:
        tinymce.init({
            selector: '#editor',
            height: 200,
            convert_urls: false,
            plugins: 'autolink emoticons image media link lists searchreplace visualblocks wordcount',
            menubar: false,
            toolbar: 'undo redo | bold italic underline strikethrough | link image media | align | checklist numlist bullist indent outdent | emoticons | removeformat',
            });
        

		function LoadComments() {
			fetch("/comment/memo/{{contentPost.memoid}}", { method: 'GET', headers: {} })
			.then(response => response.json())
			.then( response =>  {
				let commList = response;
				console.log( commList );

				let limit = commList.length;
				if (limit>0) {
					let commHtml = '';
					for (let i = 0; i < limit; i++) {
						let comm = commList[i];
						commHtml += '<div class="comment">';
						commHtml += '<div class="memoMetadata">';
						commHtml += '<h5 class="g1">';
						commHtml += comm.username;
						commHtml += ' adds:</h5>';
						commHtml += '</div>';
						commHtml += comm.text;
						commHtml += '</div>';
					}
					document.getElementById("existingComments").innerHTML = commHtml;
				}
			});
		}

		function PostComment() {
			if (gUser.hasOwnProperty('roles')) {

				// Get comment's html content
				var newCommentHTML = tinymce.get("editor").getContent();

				// post as new comment submission:
				const params = {
					"text": newCommentHTML, 
					"memoid": "{{ contentPost.memoid }}",
					"userid": gUser.userid,
					"username": gUser.username,
					"parent": 0,
				};

				const options = {
					method: 'POST',
					headers: {
						  'Accept': 'application/json',
						  'Content-Type': 'application/json',
					},
					body: JSON.stringify( params )  
				};
				fetch( '/comment', options )
					.then( response => response.json() )
					.then( response => {
						// Do something with response.
						console.log( response )
						if (response.hasOwnProperty('detail')) {
							alert( 'Please fix the following and try again: ' + response.detail )
						}
						else {
							// reload the page to see the new comment
							window.location.reload();
						}
					})
					.catch(err => {
						// Do something with the error
						console.log(err) 
						alert( err )
						// window.location.href = "/memopage/{{ contentPost.userid }}";
					}) 
			}
			else {
				// something is wrong, user should not be on this page:
				gUser = {};
				window.location.href = "/";
			}
		}
                

		function MemoEdit() { window.location.href = "/Editor/{{ contentPost.memoid }}"; }

		function Login() { window.location.href = "/login"; }

		function Register() { window.location.href = "/register"; }

		function UserSettings() { window.location.href = "/Settings"; }

		function UserProfile() { window.location.href = "/profile"; }

		// called when user clicks the "Show / Hide Uploads & Links" button
		function ToggleUploadDownloadSet() {
			let upDownSet = document.getElementById("uploadDownloadSet")
			if (upDownSet.style.display === "none") {
				upDownSet.style.display = "block";
			  } else {
				upDownSet.style.display = "none";
			  }
		}


		// called when the Input File's browse button has been operated and it's value changed:
		function onUploadChangeFunc() {
			fileInputCtrl = document.getElementById("NewUploadInput")

			let selected = fileInputCtrl.value; 	// has fake path components before filename
			const pathArray = selected.split("\\");	// prepare...
   			const lastIndex = pathArray.length - 1; // ...to remove...
			selected = pathArray[lastIndex];		// ...path components.

			fileUploadButton = document.getElementById("uploadBttn")
			fileUploadButton.innerHTML = 'Upload "' + selected + '"'

			document.getElementById("divUploadMsg").innerHTML = 'Now use the <b>Upload "' + selected + '"</b> button to upload the file'
		}
		//
		function UploadFile() {
			// Select your input type file and store it in a variable
			const input = document.getElementById('NewUploadInput');

			var data = new FormData()
			data.append('file', input.files[0])

			// This will upload the file after having read it
			const upload = (file) => {
				fetch('/upload', { // Your POST endpoint
	  				method: 'POST',
	  				headers: {},
	  				body: data // This is your file object
				}).then(
	  				response => response.json() // if the response is a JSON object
				 ).then(
	  				success => {
						console.log( success.message) // Handle the success response object
						document.getElementById("divUploadMsg").innerHTML = '<p>Success msg: ' +  success.message + '</p>';
						//
						// populate listbox for upload selection:
						get_uploads();
						//
						// clear the file upload ctrl, now that the file has been uploaded
						fileInputCtrl = document.getElementById("NewUploadInput")
						fileInputCtrl.value = '';
						//
						fileUploadButton = document.getElementById("uploadBttn")
						fileUploadButton.innerHTML = 'Select a file first'
					}
				 ).catch(
	  				error => {
						console.log( error ) // Handle the error response object
						document.getElementById("divUploadMsg").innerHTML = '<p>Error msg: ' + error + '</p>';
					}
				);
  			};
  
  			upload(input.files[0]);
		}


		// get list of uploaded files and populate upload selection list:
		const get_uploads = () => {
			let domain = (new URL(window.location));
			const prebsjnk = domain.origin;
			const furl = prebsjnk + '/upload';
			fetch(furl, { // GET endpoint
				  method: 'GET',
				  headers: {}
			}).then(
				  response => response.json() // if the response is a JSON object
			 ).then(
				  success => {
					
					console.log( success ) // Handle the success response object

					let uploadLinksWrapper = document.getElementById("divUploadLinksWrapper")
					uploadLinksWrapper.innerHTML = '';

					let fileLinks = success;
					for (let i = 0; i < fileLinks.length; i++) {
						let filename = fileLinks[i].filename;
						let fnParts = filename.split('.');
						let ext = fnParts[ fnParts.length - 1 ].toLowerCase();
						let fileType = fileLinks[i].type;
						let fileLink = fileLinks[i].link;
						
						// set this first:
						let dwnloadBttn = `<a href="#" class="button" onclick="DownloadFile('${fileLink}','${filename}')">Download this file</a>`;
						
						let docLinkBttn = `<a href="#" class="button" onclick="navigator.clipboard.writeText('${fileLink}')">Copy link to clipboard</a>`;
						if (fileType != 'image' && fileType != 'media') {
							docLinkBttn = 'cannot embed in memo/comment';
							if (ext == 'pdfXX') {
								let pdfLink = `<iframe src="` + fileLink + `" width='100%' height='200px'></iframe>`;
								let click = '"navigator.clipboard.writeText(\"' + pdfLink + '\")"';
								docLinkBttn = '<a href="#" class="button" onclick=' + click + '>Copy embed text to clipboard</a>';
							}
						}
						else if (fileType == 'media') {
							docLinkBttn = `<a href="#" class="button" onclick="navigator.clipboard.writeText('/video/${filename}')">Copy link to clipboard</a>`;
						}
						let markup = `
						<div id="divUploadLinksGridParent">
							<div id="divUploadLinksGrid0">
								<b>${filename}</b>
							</div>
							<div id="divUploadLinksGrid1">
								${fileType}
							</div>
							<div id="divUploadLinksGrid2">
								${docLinkBttn}
							</div>
							<div id="divUploadLinksGrid3">
								${dwnloadBttn}
							</div>
						</div>`;

						uploadLinksWrapper.innerHTML += markup;
					}
				}
			 ).catch(
				  error => {
					console.log( error ) // Handle the error response object
				}
			);
		  };

		// called when "Download this file" buttons are clicked
		function DownloadFile(fileUrl, filename) {
			fetch(fileUrl)
			.then(resp => resp.blob())
			.then(blob => {
				const url = window.URL.createObjectURL(blob);
				const a = document.createElement('a');
				a.style.display = 'none';
				a.href = url;
				a.download = filename;
				document.body.appendChild(a);
				a.click();
				window.URL.revokeObjectURL(url);
				alert('"' + filename + '" has downloaded.'); 
			})
			.catch(() => alert('oh no!'));
		}

	</script>

	{% include 'common_logout.html' %}

	{% include 'common_refresh.html' %}
	
</body>
</html>
